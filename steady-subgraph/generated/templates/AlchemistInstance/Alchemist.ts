// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class Initialized extends ethereum.Event {
  get params(): Initialized__Params {
    return new Initialized__Params(this);
  }
}

export class Initialized__Params {
  _event: Initialized;

  constructor(event: Initialized) {
    this._event = event;
  }

  get version(): i32 {
    return this._event.parameters[0].value.toI32();
  }
}

export class Merge extends ethereum.Event {
  get params(): Merge__Params {
    return new Merge__Params(this);
  }
}

export class Merge__Params {
  _event: Merge;

  constructor(event: Merge) {
    this._event = event;
  }

  get source(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get mergedAmount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get chyme(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get tokenid(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class Split extends ethereum.Event {
  get params(): Split__Params {
    return new Split__Params(this);
  }
}

export class Split__Params {
  _event: Split;

  constructor(event: Split) {
    this._event = event;
  }

  get source(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get splitAmount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get chymeVaultDeployed(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get chyme(): Address {
    return this._event.parameters[3].value.toAddress();
  }

  get tokenId(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }
}

export class Alchemist extends ethereum.SmartContract {
  static bind(address: Address): Alchemist {
    return new Alchemist("Alchemist", address);
  }

  academy(): Address {
    let result = super.call("academy", "academy():(address)", []);

    return result[0].toAddress();
  }

  try_academy(): ethereum.CallResult<Address> {
    let result = super.tryCall("academy", "academy():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  chyme(): Address {
    let result = super.call("chyme", "chyme():(address)", []);

    return result[0].toAddress();
  }

  try_chyme(): ethereum.CallResult<Address> {
    let result = super.tryCall("chyme", "chyme():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  elixirImpl(): Address {
    let result = super.call("elixirImpl", "elixirImpl():(address)", []);

    return result[0].toAddress();
  }

  try_elixirImpl(): ethereum.CallResult<Address> {
    let result = super.tryCall("elixirImpl", "elixirImpl():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getChyme(): Address {
    let result = super.call("getChyme", "getChyme():(address)", []);

    return result[0].toAddress();
  }

  try_getChyme(): ethereum.CallResult<Address> {
    let result = super.tryCall("getChyme", "getChyme():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  merge(tokenId: BigInt): boolean {
    let result = super.call("merge", "merge(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(tokenId)
    ]);

    return result[0].toBoolean();
  }

  try_merge(tokenId: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("merge", "merge(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(tokenId)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  split(amount: BigInt, ratioOfSteady: i32): boolean {
    let result = super.call("split", "split(uint256,uint8):(bool)", [
      ethereum.Value.fromUnsignedBigInt(amount),
      ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(ratioOfSteady))
    ]);

    return result[0].toBoolean();
  }

  try_split(amount: BigInt, ratioOfSteady: i32): ethereum.CallResult<boolean> {
    let result = super.tryCall("split", "split(uint256,uint8):(bool)", [
      ethereum.Value.fromUnsignedBigInt(amount),
      ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(ratioOfSteady))
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }
}

export class InitializeCall extends ethereum.Call {
  get inputs(): InitializeCall__Inputs {
    return new InitializeCall__Inputs(this);
  }

  get outputs(): InitializeCall__Outputs {
    return new InitializeCall__Outputs(this);
  }
}

export class InitializeCall__Inputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }

  get _chyme(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class InitializeCall__Outputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }
}

export class MergeCall extends ethereum.Call {
  get inputs(): MergeCall__Inputs {
    return new MergeCall__Inputs(this);
  }

  get outputs(): MergeCall__Outputs {
    return new MergeCall__Outputs(this);
  }
}

export class MergeCall__Inputs {
  _call: MergeCall;

  constructor(call: MergeCall) {
    this._call = call;
  }

  get tokenId(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class MergeCall__Outputs {
  _call: MergeCall;

  constructor(call: MergeCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class SplitCall extends ethereum.Call {
  get inputs(): SplitCall__Inputs {
    return new SplitCall__Inputs(this);
  }

  get outputs(): SplitCall__Outputs {
    return new SplitCall__Outputs(this);
  }
}

export class SplitCall__Inputs {
  _call: SplitCall;

  constructor(call: SplitCall) {
    this._call = call;
  }

  get amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get ratioOfSteady(): i32 {
    return this._call.inputValues[1].value.toI32();
  }
}

export class SplitCall__Outputs {
  _call: SplitCall;

  constructor(call: SplitCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}
